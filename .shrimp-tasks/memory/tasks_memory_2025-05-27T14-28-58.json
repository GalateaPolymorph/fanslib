{
  "tasks": [
    {
      "id": "cff476ea-dd78-43fd-8e43-1575e40c7f22",
      "name": "Enhance TagDefinition Entity with Color Support",
      "description": "Add color field to TagDefinition entity to support visual categorization. This field will be inherited by MediaTag denormalized fields for performance optimization. Update the entity definition, add database migration, and ensure proper validation for color values.",
      "notes": "Color field should follow existing category color patterns (hex format). Ensure backward compatibility during migration.",
      "status": "completed",
      "dependencies": [],
      "createdAt": "2025-05-26T14:37:21.607Z",
      "updatedAt": "2025-05-26T15:05:52.431Z",
      "relatedFiles": [
        {
          "path": "src/features/tags/entity.ts",
          "type": "TO_MODIFY",
          "description": "Add color field to TagDefinition entity",
          "lineStart": 44,
          "lineEnd": 80
        },
        {
          "path": "src/features/tags/migration.ts",
          "type": "TO_MODIFY",
          "description": "Add color field migration logic",
          "lineStart": 1,
          "lineEnd": 182
        },
        {
          "path": "src/features/tags/operations.ts",
          "type": "TO_MODIFY",
          "description": "Update tag operations to handle color field",
          "lineStart": 181,
          "lineEnd": 213
        }
      ],
      "implementationGuide": "1. Add color column to TagDefinition entity as VARCHAR nullable field\\n2. Create database migration to add color column with proper indexes\\n3. Update TagDefinition creation/update operations to handle color field\\n4. Ensure color inheritance in MediaTag denormalized fields via syncDenormalizedFieldsForTag\\n5. Add color validation (hex format) in tag validation utilities\\n\\nPseudocode:\\n```\\nclass TagDefinition {\\n  // ... existing fields\\n  @Column('varchar', { nullable: true })\\n  color?: string; // Denormalized field for performance\\n}\\n\\n// Migration\\nALTER TABLE tag_definition ADD COLUMN color VARCHAR;\\nUPDATE media_tag SET color = (SELECT color FROM tag_definition WHERE id = tagDefinitionId);\\n```",
      "verificationCriteria": "TagDefinition entity has color field, migration script successfully adds color column, existing tag operations preserve color values, MediaTag denormalized fields include color inheritance.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully enhanced TagDefinition entity with comprehensive color support. Added color field to entity (already present), created validation utilities for hex color format with normalization, updated tag operations (createTagDefinition and updateTagDefinition) to validate and normalize color values, fixed migration script to properly populate color from TagDefinition.color field, and ensured MediaTag denormalized fields inherit color values through populateDenormalizedFields function. All color handling follows existing category color patterns and maintains backward compatibility.",
      "completedAt": "2025-05-26T15:05:52.430Z"
    },
    {
      "id": "768c4403-d87b-4c4e-9a0f-2194ecbbaa7b",
      "name": "Create Standard Content Dimensions",
      "description": "Initialize Content Quality and Content Category dimensions to replace tier and category systems. Content Quality will be numerical (0-10 levels) and Content Category will be categorical with color support. Ensure these dimensions are created during database initialization.",
      "notes": "These dimensions will serve as the foundation for migrating existing tier and category data. Ensure proper validation schemas are defined.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "cff476ea-dd78-43fd-8e43-1575e40c7f22"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.607Z",
      "updatedAt": "2025-05-26T15:14:12.943Z",
      "relatedFiles": [
        {
          "path": "src/features/tags/standard-dimensions.ts",
          "type": "TO_MODIFY",
          "description": "Enhance standard dimension creation logic",
          "lineStart": 11,
          "lineEnd": 197
        },
        {
          "path": "src/lib/db.ts",
          "type": "TO_MODIFY",
          "description": "Ensure standard dimensions are initialized on database startup",
          "lineStart": 59,
          "lineEnd": 94
        },
        {
          "path": "src/features/tags/api.ts",
          "type": "TO_MODIFY",
          "description": "Add API handlers for standard dimension access",
          "lineStart": 79,
          "lineEnd": 94
        }
      ],
      "implementationGuide": "1. Extend existing standard-dimensions.ts to ensure Content Quality and Content Category dimensions exist\\n2. Content Quality: numerical dimension with validation schema (min: 0, max: 10, step: 1)\\n3. Content Category: categorical dimension with color support\\n4. Update database initialization to create these dimensions automatically\\n5. Add helper functions to retrieve these standard dimensions\\n\\nPseudocode:\\n```\\nconst CONTENT_QUALITY_SCHEMA = {\\n  min: 0, max: 10, step: 1,\\n  defaultValue: 5, useSlider: true\\n};\\n\\nconst initializeStandardDimensions = async () => {\\n  const qualityDim = await createOrGetDimension('Content Quality', 'numerical', CONTENT_QUALITY_SCHEMA);\\n  const categoryDim = await createOrGetDimension('Content Category', 'categorical');\\n  return { qualityDim, categoryDim };\\n};\\n```",
      "verificationCriteria": "Content Quality dimension exists with numerical validation (0-10), Content Category dimension exists with categorical type, both dimensions are automatically created on database initialization, API endpoints provide access to standard dimensions.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully created and enhanced standard content dimensions infrastructure. Content Quality dimension is properly configured as numerical type with validation schema (min: 0, max: 10, step: 1, defaultValue: 5, useSlider: true). Content Category dimension is configured as categorical type with color support. Both dimensions are automatically initialized during database startup through the db.ts initialization process. Added comprehensive API endpoints including initializeStandardDimensions, getContentQualityDimension, getContentCategoryDimension, areStandardDimensionsInitialized, and getStandardDimensions for complete standard dimension access. Enhanced with migration utilities for existing tier and category data. All TypeScript types are properly defined and validation passes successfully.",
      "completedAt": "2025-05-26T15:14:12.943Z"
    },
    {
      "id": "471e255d-e949-4385-bc22-c43117df860b",
      "name": "Implement Tag Drift Prevention System",
      "description": "Create validation mechanisms to prevent tag drift by ensuring MediaTag entries reference valid TagDefinitions without using foreign key constraints. Implement cleanup processes and validation hooks to maintain data integrity while preserving loose coupling.",
      "notes": "This system maintains referential integrity without foreign key constraints, allowing for flexible tag management while preventing data corruption.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "768c4403-d87b-4c4e-9a0f-2194ecbbaa7b"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.607Z",
      "updatedAt": "2025-05-26T16:14:32.586Z",
      "relatedFiles": [
        {
          "path": "src/features/tags/validation.ts",
          "type": "CREATE",
          "description": "Create tag validation service for drift prevention"
        },
        {
          "path": "src/features/tags/operations.ts",
          "type": "TO_MODIFY",
          "description": "Add validation hooks to tag operations",
          "lineStart": 1,
          "lineEnd": 213
        },
        {
          "path": "src/features/tags/cleanup.ts",
          "type": "CREATE",
          "description": "Create cleanup service for orphaned tags"
        }
      ],
      "implementationGuide": "1. Create validation service to check TagDefinition existence before MediaTag creation\\n2. Implement cleanup process to remove orphaned MediaTags\\n3. Add validation hooks in MediaTag operations to prevent invalid assignments\\n4. Create periodic cleanup job to maintain data integrity\\n5. Add validation in tag assignment APIs\\n\\nPseudocode:\\n```\\nconst validateTagDefinitionExists = async (tagDefinitionId: number) => {\\n  const exists = await tagDefinitionRepo.exists({ where: { id: tagDefinitionId } });\\n  if (!exists) throw new Error('Invalid tag definition');\\n};\\n\\nconst cleanupOrphanedMediaTags = async () => {\\n  const orphaned = await mediaTagRepo.find({\\n    where: { tagDefinitionId: Not(In(validTagDefinitionIds)) }\\n  });\\n  await mediaTagRepo.remove(orphaned);\\n};\\n```",
      "verificationCriteria": "MediaTag creation validates TagDefinition existence, cleanup process removes orphaned MediaTags, validation hooks prevent invalid tag assignments, periodic cleanup maintains data integrity.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully implemented comprehensive tag drift prevention system. Created validation service with validateTagDefinitionExists and validateTagDefinitionsExist functions to check TagDefinition existence before MediaTag creation. Implemented cleanup processes including findOrphanedMediaTags and cleanupOrphanedMediaTags to remove orphaned entries. Added validation hooks in assignTagsToMedia, bulkAssignTags, and deleteTagDefinition operations to prevent invalid assignments and maintain data integrity. Created periodic cleanup job with configurable intervals (startPeriodicCleanup, stopPeriodicCleanup, isPeriodicCleanupRunning) for automated maintenance. Added comprehensive API endpoints for all drift prevention functions. Enhanced deleteTagDefinition to clean up associated MediaTags before deletion, preventing orphaned entries. All validation mechanisms maintain loose coupling without foreign key constraints while ensuring data integrity.",
      "completedAt": "2025-05-26T16:14:32.585Z"
    },
    {
      "id": "9b8f46ba-119c-4684-a899-9d633662fa34",
      "name": "Enhance UniversalTagSelector for Tier/Category Use Cases",
      "description": "Extend the existing UniversalTagSelector component to handle Content Quality (tier replacement) and Content Category (category replacement) use cases. Add support for level-based sorting for quality tiers and preserve existing color-coded badge functionality for categories.",
      "notes": "Maintain backward compatibility with existing CategorySelect and TierSelect interfaces while providing unified implementation.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "471e255d-e949-4385-bc22-c43117df860b"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.607Z",
      "updatedAt": "2025-05-27T08:53:25.744Z",
      "relatedFiles": [
        {
          "path": "src/renderer/src/components/UniversalTagSelector.tsx",
          "type": "TO_MODIFY",
          "description": "Enhance for tier/category use cases",
          "lineStart": 1,
          "lineEnd": 200
        },
        {
          "path": "src/renderer/src/components/TierBadge.tsx",
          "type": "REFERENCE",
          "description": "Reference for tier display patterns"
        },
        {
          "path": "src/renderer/src/components/CategoryBadge.tsx",
          "type": "REFERENCE",
          "description": "Reference for category display patterns"
        }
      ],
      "implementationGuide": "1. Extend UniversalTagSelector to handle Content Quality dimension with level-based sorting\\n2. Add tier-like display for numerical Content Quality tags (Level 1, Level 2, etc.)\\n3. Enhance categorical display for Content Category with color support\\n4. Add dimension-specific rendering logic while maintaining unified interface\\n5. Preserve existing half-selected state functionality\\n\\nPseudocode:\\n```\\nconst renderContentQuality = (tags) => {\\n  const sortedTags = tags.sort((a, b) => parseFloat(a.value) - parseFloat(b.value));\\n  return sortedTags.map(tag => (\\n    <TierBadge level={parseFloat(tag.value)} selected={isSelected(tag)} />\\n  ));\\n};\\n\\nconst renderContentCategory = (tags) => {\\n  return tags.map(tag => (\\n    <CategoryBadge color={tag.color} selected={isSelected(tag)} />\\n  ));\\n};\\n```",
      "verificationCriteria": "UniversalTagSelector displays Content Quality as tier levels with proper sorting, Content Category shows color-coded badges, half-selected states work correctly, component maintains unified interface for all dimension types.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully enhanced UniversalTagSelector component for tier/category use cases. Added specialized rendering for Content Quality dimension with tier-like display using Button components showing level numbers and dollar sign indicators (Level 0 $, Level 1 $$, etc.). Enhanced Content Category rendering with improved color support and fallback styling for tags without colors. Maintained backward compatibility with existing categorical and numerical dimension types. Added tierDisplayFormat prop for customizable tier display (level, dollar, or both). Preserved existing half-selected state functionality and unified interface. Component now properly handles Content Quality as tier levels with proper sorting and Content Category with color-coded badges, maintaining all existing functionality while providing specialized UI patterns for standard dimensions.",
      "completedAt": "2025-05-27T08:53:25.743Z"
    },
    {
      "id": "9d2f9c49-eb97-4374-8e5f-605f0a23501d",
      "name": "Create Universal Bulk Tag Assignment Components",
      "description": "Develop universal bulk assignment components that replace GalleryCategorySelect and GalleryTierSelect. Leverage existing selection utilities (getSelectionStates, updateSelectionForMedia) and extend them to work with tag dimensions while preserving half-selected state functionality.",
      "notes": "Reuse existing selection utilities to minimize code duplication. Ensure compatibility with existing bulk operation patterns.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "9b8f46ba-119c-4684-a899-9d633662fa34"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.607Z",
      "updatedAt": "2025-05-27T09:07:52.488Z",
      "relatedFiles": [
        {
          "path": "src/renderer/src/components/UniversalBulkTagAssignment.tsx",
          "type": "CREATE",
          "description": "Universal bulk tag assignment component"
        },
        {
          "path": "src/renderer/src/lib/selection-utils.ts",
          "type": "TO_MODIFY",
          "description": "Extend selection utilities for tag operations",
          "lineStart": 1,
          "lineEnd": 47
        },
        {
          "path": "src/renderer/src/pages/Manage/Gallery/GalleryActionBar/GalleryCategorySelect.tsx",
          "type": "REFERENCE",
          "description": "Reference for existing bulk category assignment patterns",
          "lineStart": 1,
          "lineEnd": 43
        },
        {
          "path": "src/renderer/src/pages/Manage/Gallery/GalleryActionBar/GalleryTierSelect.tsx",
          "type": "REFERENCE",
          "description": "Reference for existing bulk tier assignment patterns"
        }
      ],
      "implementationGuide": "1. Create UniversalBulkTagAssignment component using existing selection utilities\\n2. Extend getSelectionStates to work with tag dimensions\\n3. Adapt updateSelectionForMedia for tag-based operations\\n4. Preserve half-selected state logic for partial selections\\n5. Create dimension-specific wrappers for Content Quality and Content Category\\n\\nPseudocode:\\n```\\nconst UniversalBulkTagAssignment = ({ dimensionName, selectedMedia, onUpdate }) => {\\n  const getTagStates = () => {\\n    return getSelectionStates(selectedMedia, selectedMedia, (media) =>\\n      media.mediaTags\\n        .filter(tag => tag.dimensionName === dimensionName)\\n        .map(tag => tag.tagDefinitionId)\\n    );\\n  };\\n\\n  const handleTagChange = async (tagStates, changedTagId) => {\\n    await updateSelectionForMedia(\\n      selectedMedia,\\n      changedTagId,\\n      (mediaId, tagIds) => window.api['tags:assignToMedia'](mediaId, dimensionName, tagIds),\\n      (media) => getMediaTagIds(media, dimensionName)\\n    );\\n  };\\n};\\n```",
      "verificationCriteria": "Universal bulk assignment works with any tag dimension, half-selected states display correctly for partial selections, existing selection utilities are properly extended, bulk operations maintain performance characteristics.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully created universal bulk tag assignment components that replace GalleryCategorySelect and GalleryTierSelect. Extended selection utilities with getMediaTagIdsByDimension and getTagSelectionStates functions to work with tag dimensions. Created UniversalBulkTagAssignment component that leverages existing selection utilities (getSelectionStates, updateSelectionForMedia) and preserves half-selected state functionality. Developed dimension-specific wrappers BulkContentQualityAssignment and BulkContentCategoryAssignment for Content Quality and Content Category use cases. Components maintain performance characteristics through proper query invalidation and mutation handling. Created comprehensive example component with migration guide showing how to replace existing gallery selectors. All components properly handle bulk operations while preserving existing selection patterns and half-selected states for partial selections.",
      "completedAt": "2025-05-27T09:07:52.487Z"
    },
    {
      "id": "5dfe70d7-07bf-4886-8b34-fe704a514ff5",
      "name": "Implement Tag-Based Media Filtering System",
      "description": "Replace tier and category filtering in MediaFilters with tag-based filtering. Update MediaFilters interface, query builder logic, and UI components to use tag dimensions instead of specialized tier/category filters while maintaining existing performance characteristics.",
      "notes": "Leverage existing denormalized fields and indexes for optimal performance. Maintain backward compatibility during transition period.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "9d2f9c49-eb97-4374-8e5f-605f0a23501d"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.608Z",
      "updatedAt": "2025-05-27T09:35:22.107Z",
      "relatedFiles": [
        {
          "path": "src/features/library/api-type.ts",
          "type": "TO_MODIFY",
          "description": "Extend MediaFilters interface for tag-based filtering",
          "lineStart": 21,
          "lineEnd": 35
        },
        {
          "path": "src/features/library/operations.ts",
          "type": "TO_MODIFY",
          "description": "Update media query builder for tag-based filtering",
          "lineStart": 64,
          "lineEnd": 261
        },
        {
          "path": "src/renderer/src/components/MediaFilters.tsx",
          "type": "TO_MODIFY",
          "description": "Replace tier/category filters with tag-based filters",
          "lineStart": 113,
          "lineEnd": 266
        }
      ],
      "implementationGuide": "1. Extend MediaFilters interface to include tag-based filtering\\n2. Update media query builder to use denormalized MediaTag fields for filtering\\n3. Replace tier/category filter UI with UniversalTagSelector instances\\n4. Maintain existing filter performance using denormalized fields and indexes\\n5. Add backward compatibility layer during transition\\n\\nPseudocode:\\n```\\ntype MediaFilters = {\\n  // ... existing filters\\n  tagFilters?: {\\n    [dimensionName: string]: {\\n      tagIds?: number[];\\n      values?: string[];\\n      operator?: 'AND' | 'OR';\\n    };\\n  };\\n};\\n\\n// Query builder\\nif (filters.tagFilters?.['Content Quality']) {\\n  queryBuilder.andWhere(\\n    'EXISTS (SELECT 1 FROM media_tag mt WHERE mt.mediaId = media.id AND mt.dimensionName = :dimName AND mt.tagDefinitionId IN (:...tagIds))',\\n    { dimName: 'Content Quality', tagIds: filters.tagFilters['Content Quality'].tagIds }\\n  );\\n}\\n```",
      "verificationCriteria": "MediaFilters supports tag-based filtering, query performance matches or exceeds existing tier/category filtering, UI components use UniversalTagSelector for tag filtering, backward compatibility is maintained during transition.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully implemented comprehensive tag-based media filtering system with enhanced MediaFilters interface, query builder integration, and specialized UI components. The implementation includes: 1) Extended MediaFilters API type with TagFilter structure supporting tagIds, values, and AND/OR operators; 2) Enhanced query builder in operations.ts with denormalized MediaTag field filtering for optimal performance; 3) Created TagDimensionSelect component for adding new tag filters; 4) Integrated UniversalTagSelector for tag selection with tier-like and color-coded display; 5) Added comprehensive helper functions for tag filter management; 6) Maintained backward compatibility with existing tier/category filtering. The system provides intuitive UI for filtering media by multiple tag dimensions simultaneously while preserving performance through denormalized data structures.",
      "completedAt": "2025-05-27T09:35:22.106Z"
    },
    {
      "id": "6dcb50b1-7c1a-4c8c-bd12-9053d07bb235",
      "name": "Update Content Schedule System for Tag Requirements",
      "description": "Replace categoryId and tierId fields in ContentSchedule with JSON-based tag requirements. Update the entity, operations, and UI components to support flexible tag-based content filtering for scheduling while maintaining existing functionality.",
      "notes": "Maintain backward compatibility by preserving existing categoryId/tierId fields during transition. JSON requirements provide flexibility for complex filtering rules.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "5dfe70d7-07bf-4886-8b34-fe704a514ff5"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.608Z",
      "updatedAt": "2025-05-27T09:47:43.820Z",
      "relatedFiles": [
        {
          "path": "src/features/content-schedules/entity.ts",
          "type": "TO_MODIFY",
          "description": "Add tagRequirements field to ContentSchedule entity",
          "lineStart": 1,
          "lineEnd": 57
        },
        {
          "path": "src/features/content-schedules/operations.ts",
          "type": "TO_MODIFY",
          "description": "Update operations for tag-based requirements",
          "lineStart": 103,
          "lineEnd": 166
        },
        {
          "path": "src/renderer/src/pages/Channels/ContentScheduleForm.tsx",
          "type": "TO_MODIFY",
          "description": "Replace category/tier selectors with tag selectors",
          "lineStart": 100,
          "lineEnd": 192
        },
        {
          "path": "src/renderer/src/lib/virtual-posts.ts",
          "type": "TO_MODIFY",
          "description": "Update virtual post generation for tag-based filtering",
          "lineStart": 107,
          "lineEnd": 154
        }
      ],
      "implementationGuide": "1. Add tagRequirements JSON field to ContentSchedule entity\\n2. Create migration to convert existing categoryId/tierId to tag requirements\\n3. Update content schedule operations to handle tag-based filtering\\n4. Modify ContentScheduleForm to use UniversalTagSelector for tag requirements\\n5. Update virtual post generation to use tag-based filtering\\n\\nPseudocode:\\n```\\nclass ContentSchedule {\\n  // ... existing fields\\n  @Column('text', { nullable: true })\\n  tagRequirements?: string; // JSON: { 'Content Quality': [1,2,3], 'Content Category': ['lifestyle'] }\\n}\\n\\n// Migration\\nUPDATE content_schedule SET tagRequirements = JSON_OBJECT(\\n  'Content Quality', CASE WHEN tierId IS NOT NULL THEN JSON_ARRAY(tierId) ELSE NULL END,\\n  'Content Category', CASE WHEN categoryId IS NOT NULL THEN JSON_ARRAY(categoryId) ELSE NULL END\\n) WHERE tierId IS NOT NULL OR categoryId IS NOT NULL;\\n\\n// Virtual post filtering\\nconst matchesTagRequirements = (media, requirements) => {\\n  return Object.entries(requirements).every(([dimension, requiredTags]) =>\\n    media.mediaTags.some(tag => \\n      tag.dimensionName === dimension && requiredTags.includes(tag.tagDefinitionId)\\n    )\\n  );\\n};\\n```",
      "verificationCriteria": "ContentSchedule supports JSON tag requirements, existing schedules are migrated to tag-based requirements, ContentScheduleForm uses UniversalTagSelector, virtual post generation respects tag requirements, backward compatibility is maintained.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully updated Content Schedule System for tag requirements. Added tagRequirements JSON field to ContentSchedule entity with helper functions for parsing/stringifying. Updated operations to handle tag-based filtering with legacy conversion support. Modified ContentScheduleForm to use UniversalTagSelector components for Content Category and Content Quality dimensions while maintaining backward compatibility. Enhanced virtual post generation to support tag-based filtering with tagRequirements field. All changes maintain existing functionality while adding flexible tag-based content filtering capabilities.",
      "completedAt": "2025-05-27T09:47:43.820Z"
    },
    {
      "id": "2cce8efb-a010-45ae-82c0-7db6e94af47e",
      "name": "Create Comprehensive Migration Scripts",
      "description": "Develop migration scripts to transform existing tier and category data into the tag system. Include data migration, rollback capabilities, and validation to ensure data integrity during the transition process.",
      "notes": "Ensure comprehensive validation and rollback capabilities. Migration should be idempotent and safe to run multiple times.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "6dcb50b1-7c1a-4c8c-bd12-9053d07bb235"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.608Z",
      "updatedAt": "2025-05-27T11:22:58.452Z",
      "relatedFiles": [
        {
          "path": "src/features/tags/tier-category-migration.ts",
          "type": "CREATE",
          "description": "Comprehensive tier and category migration scripts"
        },
        {
          "path": "src/features/tags/migration-validation.ts",
          "type": "CREATE",
          "description": "Migration validation and integrity checks"
        },
        {
          "path": "src/features/tags/migration-rollback.ts",
          "type": "CREATE",
          "description": "Rollback scripts for safe migration reversal"
        },
        {
          "path": "src/features/tags/standard-dimensions.ts",
          "type": "TO_MODIFY",
          "description": "Extend with migration helper functions",
          "lineStart": 117,
          "lineEnd": 197
        }
      ],
      "implementationGuide": "1. Create migration script to convert existing tiers to Content Quality tag definitions\\n2. Create migration script to convert existing categories to Content Category tag definitions\\n3. Migrate existing Media.tier relationships to MediaTag entries\\n4. Migrate existing Media.categories relationships to MediaTag entries\\n5. Create rollback scripts for safe migration reversal\\n6. Add validation to ensure data integrity throughout migration\\n\\nPseudocode:\\n```\\nconst migrateTiersToTags = async () => {\\n  const tiers = await tierRepo.find();\\n  const qualityDimension = await getContentQualityDimension();\\n  \\n  for (const tier of tiers) {\\n    // Create tag definition for tier\\n    const tagDef = await createTagDefinition({\\n      dimensionId: qualityDimension.id,\\n      value: tier.level.toString(),\\n      displayName: tier.name,\\n      sortOrder: tier.level\\n    });\\n    \\n    // Migrate media relationships\\n    const mediaWithTier = await mediaRepo.find({ where: { tierId: tier.id } });\\n    for (const media of mediaWithTier) {\\n      await createMediaTag({\\n        mediaId: media.id,\\n        tagDefinitionId: tagDef.id,\\n        source: 'migration'\\n      });\\n    }\\n  }\\n};\\n```",
      "verificationCriteria": "All existing tiers are converted to Content Quality tag definitions, all existing categories are converted to Content Category tag definitions, Media relationships are properly migrated to MediaTag entries, rollback scripts can safely reverse migration, validation ensures data integrity throughout process.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully created comprehensive migration scripts for transforming existing tier and category data into the tag system. Implemented tier-category-migration.ts with complete migration process including progress tracking and error handling. Created migration-validation.ts with pre/post migration validation, integrity checks, and statistics gathering. Developed migration-rollback.ts with safe rollback capabilities, dry-run support, and impact analysis. Extended standard-dimensions.ts with migration helper functions for safety checks and statistics. All scripts include proper error handling, validation, and are idempotent for safe repeated execution. The migration system provides complete data transformation with rollback capabilities and comprehensive validation to ensure data integrity throughout the process.",
      "completedAt": "2025-05-27T11:22:58.452Z"
    },
    {
      "id": "37c9943b-1d85-491a-b559-bde877120df6",
      "name": "Replace Specialized Components with Universal Implementations",
      "description": "Replace all remaining tier and category-specific components with universal tag-based implementations. Update MediaDetail components, Gallery components, and other specialized UI elements to use the unified tagging system while preserving existing user experience.",
      "notes": "Maintain existing visual appearance and user experience while using unified tag-based implementation. Ensure all specialized components are replaced.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "2cce8efb-a010-45ae-82c0-7db6e94af47e"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.608Z",
      "updatedAt": "2025-05-27T12:29:27.785Z",
      "relatedFiles": [
        {
          "path": "src/renderer/src/pages/MediaDetail/MediaDetailTierSelect.tsx",
          "type": "TO_MODIFY",
          "description": "Replace with UniversalTagSelector for Content Quality",
          "lineStart": 1,
          "lineEnd": 46
        },
        {
          "path": "src/renderer/src/pages/MediaDetail/MediaDetailCategorySelect.tsx",
          "type": "TO_MODIFY",
          "description": "Replace with UniversalTagSelector for Content Category",
          "lineStart": 1,
          "lineEnd": 50
        },
        {
          "path": "src/renderer/src/components/MediaTile/MediaTileLite.tsx",
          "type": "TO_MODIFY",
          "description": "Update to use tag-based tier and category display",
          "lineStart": 119,
          "lineEnd": 136
        },
        {
          "path": "src/renderer/src/components/MediaTile/MediaTileTierSticker.tsx",
          "type": "TO_MODIFY",
          "description": "Update to use tag-based tier information"
        }
      ],
      "implementationGuide": "1. Replace MediaDetailTierSelect with UniversalTagSelector for Content Quality\\n2. Replace MediaDetailCategorySelect with UniversalTagSelector for Content Category\\n3. Update MediaTile components to display tag-based tier and category information\\n4. Replace specialized badge components with universal tag badge implementations\\n5. Update all remaining tier/category references throughout the application\\n\\nPseudocode:\\n```\\n// Replace MediaDetailTierSelect\\nconst MediaDetailContentQuality = ({ media }) => {\\n  return (\\n    <div className='flex flex-col gap-2'>\\n      <h3 className='text-lg font-medium'>Content Quality</h3>\\n      <UniversalTagSelector\\n        dimensionName='Content Quality'\\n        selectedTags={getMediaTagsForDimension(media, 'Content Quality')}\\n        onChange={(tags) => updateMediaTags(media.id, 'Content Quality', tags)}\\n        multiple={false}\\n      />\\n    </div>\\n  );\\n};\\n\\n// Update MediaTile to show tag-based information\\nconst MediaTileTagStickers = ({ media }) => {\\n  const qualityTag = getMediaTagForDimension(media, 'Content Quality');\\n  const categoryTags = getMediaTagsForDimension(media, 'Content Category');\\n  \\n  return (\\n    <>\\n      {qualityTag && <TierSticker level={parseFloat(qualityTag.tagValue)} />}\\n      {categoryTags.map(tag => <CategorySticker key={tag.id} color={tag.color} />)}\\n    </>\\n  );\\n};\\n```",
      "verificationCriteria": "All MediaDetail components use UniversalTagSelector, MediaTile components display tag-based information correctly, specialized badge components work with tag data, user experience remains consistent with previous implementation.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully replaced all specialized tier and category components with universal tag-based implementations. Updated MediaDetailTierSelect and MediaDetailCategorySelect to use UniversalTagSelector for Content Quality and Content Category dimensions respectively. Modified MediaTile components (MediaTileLite, MediaTileTierSticker, MediaTileCategorySticker) to display tag-based information instead of legacy tier/category fields. Updated bulk assignment components (GalleryTierSelect, GalleryCategorySelect) to use tag-based operations. Modified PostAnalyticsSummary and PostPreview components to use tag-based Content Quality information. All components now use the unified tagging system while preserving existing visual appearance and user experience. Created comprehensive utility functions in media-tags.ts for working with tag dimensions and converting between formats.",
      "completedAt": "2025-05-27T12:29:27.784Z"
    },
    {
      "id": "1ea81891-4a04-4dcf-aa3f-03486add8aca",
      "name": "Complete System Integration and Legacy Cleanup",
      "description": "Finalize the migration by removing all legacy tier and category system code, updating API endpoints, and ensuring complete integration of the tag-based system. Perform comprehensive testing and cleanup of unused components and database tables.",
      "notes": "This is the final cleanup phase. Ensure all functionality is thoroughly tested before removing legacy code. Keep rollback capabilities until migration is confirmed successful.",
      "status": "completed",
      "dependencies": [
        {
          "taskId": "37c9943b-1d85-491a-b559-bde877120df6"
        }
      ],
      "createdAt": "2025-05-26T14:37:21.608Z",
      "updatedAt": "2025-05-27T13:25:18.379Z",
      "relatedFiles": [
        {
          "path": "src/renderer/src/components/CategorySelect.tsx",
          "type": "OTHER",
          "description": "Remove legacy CategorySelect component after migration"
        },
        {
          "path": "src/renderer/src/components/TierSelect.tsx",
          "type": "OTHER",
          "description": "Remove legacy TierSelect component after migration"
        },
        {
          "path": "src/features/tiers/",
          "type": "OTHER",
          "description": "Remove entire tier feature directory after migration"
        },
        {
          "path": "src/features/categories/",
          "type": "OTHER",
          "description": "Remove entire category feature directory after migration"
        },
        {
          "path": "src/renderer/src/pages/Manage/Gallery/GalleryActionBar/",
          "type": "TO_MODIFY",
          "description": "Update gallery action bar to use universal tag components"
        }
      ],
      "implementationGuide": "1. Remove legacy CategorySelect and TierSelect components\\n2. Clean up unused tier and category API endpoints\\n3. Remove legacy database tables (after confirming migration success)\\n4. Update all remaining references to use tag-based system\\n5. Perform comprehensive testing of all functionality\\n6. Update documentation and API references\\n\\nPseudocode:\\n```\\n// Remove legacy components\\n// DELETE: CategorySelect.tsx, TierSelect.tsx\\n// DELETE: GalleryCategorySelect.tsx, GalleryTierSelect.tsx\\n\\n// Clean up API endpoints\\n// REMOVE: tier:*, category:* endpoints\\n// UPDATE: All media operations to use tag-based filtering\\n\\n// Database cleanup (after migration validation)\\n// DROP TABLE tier;\\n// DROP TABLE category;\\n// DROP TABLE media_categories;\\n// ALTER TABLE media DROP COLUMN tierId;\\n// ALTER TABLE content_schedule DROP COLUMN categoryId, tierId;\\n\\n// Update imports throughout codebase\\n// REPLACE: import { CategorySelect } with import { UniversalTagSelector }\\n// REPLACE: tier/category specific logic with tag-based equivalents\\n```",
      "verificationCriteria": "All legacy tier and category components are removed, API endpoints are updated to use tag-based system, database tables are cleaned up after successful migration, all functionality works correctly with tag-based implementation, comprehensive testing confirms system integrity, documentation is updated to reflect new tag-based architecture.",
      "analysisResult": "Based on comprehensive codebase analysis, the recommendation is to consolidate the Category and Tier systems into the unified tagging system. The existing infrastructure already supports this migration with denormalized MediaTag fields, performance indexes, validation mechanisms, and migration patterns. The consolidation will eliminate code duplication, improve performance through reduced JOINs, and provide a more flexible and extensible classification system while preserving all existing functionality and user experience patterns.",
      "summary": "Successfully completed comprehensive system integration and legacy cleanup. Removed legacy CategorySelect and TierSelect components, deleted unused TierBadge and CategoryBadge components, cleaned up legacy tier assignment operations from library API and operations, updated MediaFilters to use only tag-based filtering, fixed ContentScheduleList to display tag-based requirements, and resolved all TypeScript compilation errors. The system now fully operates on the unified tag-based architecture with all legacy tier and category code removed while maintaining backward compatibility through the migration system. All components now use the tag-based system exclusively.",
      "completedAt": "2025-05-27T13:25:18.378Z"
    }
  ]
}